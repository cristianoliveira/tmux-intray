// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlcgen

import (
	"context"
	"database/sql"
)

const countActiveNotifications = `-- name: CountActiveNotifications :one
SELECT COUNT(1)
FROM notifications
WHERE state = 'active'
`

func (q *Queries) CountActiveNotifications(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveNotifications)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDismissedForCleanup = `-- name: CountDismissedForCleanup :one
SELECT COUNT(1)
FROM notifications
WHERE state = 'dismissed'
  AND (?1 = '' OR timestamp < ?1)
`

func (q *Queries) CountDismissedForCleanup(ctx context.Context, cutoff interface{}) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDismissedForCleanup, cutoff)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNotification = `-- name: CreateNotification :exec
INSERT INTO notifications (
    id,
    timestamp,
    state,
    session,
    window,
    pane,
    message,
    pane_created,
    level,
    read_timestamp,
    updated_at
)
VALUES (?, ?, 'active', ?, ?, ?, ?, ?, ?, '', ?)
`

type CreateNotificationParams struct {
	ID          int64
	Timestamp   string
	Session     string
	Window      string
	Pane        string
	Message     string
	PaneCreated string
	Level       string
	UpdatedAt   string
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) error {
	_, err := q.db.ExecContext(ctx, createNotification,
		arg.ID,
		arg.Timestamp,
		arg.Session,
		arg.Window,
		arg.Pane,
		arg.Message,
		arg.PaneCreated,
		arg.Level,
		arg.UpdatedAt,
	)
	return err
}

const deleteDismissedForCleanup = `-- name: DeleteDismissedForCleanup :exec
DELETE FROM notifications
WHERE state = 'dismissed'
  AND (?1 = '' OR timestamp < ?1)
`

func (q *Queries) DeleteDismissedForCleanup(ctx context.Context, cutoff interface{}) error {
	_, err := q.db.ExecContext(ctx, deleteDismissedForCleanup, cutoff)
	return err
}

const dismissNotificationByID = `-- name: DismissNotificationByID :execresult
UPDATE notifications
SET state = 'dismissed', updated_at = ?1
WHERE id = ?2
`

type DismissNotificationByIDParams struct {
	UpdatedAt string
	ID        int64
}

func (q *Queries) DismissNotificationByID(ctx context.Context, arg DismissNotificationByIDParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, dismissNotificationByID, arg.UpdatedAt, arg.ID)
}

const getNotificationForHooksByID = `-- name: GetNotificationForHooksByID :one
SELECT id, timestamp, state, session, window, pane, message, pane_created, level
FROM notifications
WHERE id = ?
`

type GetNotificationForHooksByIDRow struct {
	ID          int64
	Timestamp   string
	State       string
	Session     string
	Window      string
	Pane        string
	Message     string
	PaneCreated string
	Level       string
}

func (q *Queries) GetNotificationForHooksByID(ctx context.Context, id int64) (GetNotificationForHooksByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getNotificationForHooksByID, id)
	var i GetNotificationForHooksByIDRow
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.State,
		&i.Session,
		&i.Window,
		&i.Pane,
		&i.Message,
		&i.PaneCreated,
		&i.Level,
	)
	return i, err
}

const getNotificationLineByID = `-- name: GetNotificationLineByID :one
SELECT id, timestamp, state, session, window, pane, message, pane_created, level, read_timestamp
FROM notifications
WHERE id = ?
`

type GetNotificationLineByIDRow struct {
	ID            int64
	Timestamp     string
	State         string
	Session       string
	Window        string
	Pane          string
	Message       string
	PaneCreated   string
	Level         string
	ReadTimestamp string
}

func (q *Queries) GetNotificationLineByID(ctx context.Context, id int64) (GetNotificationLineByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getNotificationLineByID, id)
	var i GetNotificationLineByIDRow
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.State,
		&i.Session,
		&i.Window,
		&i.Pane,
		&i.Message,
		&i.PaneCreated,
		&i.Level,
		&i.ReadTimestamp,
	)
	return i, err
}

const listActiveNotificationsForHooks = `-- name: ListActiveNotificationsForHooks :many
SELECT id, timestamp, state, session, window, pane, message, pane_created, level
FROM notifications
WHERE state = 'active'
ORDER BY id ASC
`

type ListActiveNotificationsForHooksRow struct {
	ID          int64
	Timestamp   string
	State       string
	Session     string
	Window      string
	Pane        string
	Message     string
	PaneCreated string
	Level       string
}

func (q *Queries) ListActiveNotificationsForHooks(ctx context.Context) ([]ListActiveNotificationsForHooksRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveNotificationsForHooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveNotificationsForHooksRow
	for rows.Next() {
		var i ListActiveNotificationsForHooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.State,
			&i.Session,
			&i.Window,
			&i.Pane,
			&i.Message,
			&i.PaneCreated,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotifications = `-- name: ListNotifications :many
SELECT id, timestamp, state, session, window, pane, message, pane_created, level, read_timestamp
FROM notifications
WHERE (?1 = '' OR ?1 = 'all' OR state = ?1)
  AND (?2 = '' OR level = ?2)
  AND (?3 = '' OR session = ?3)
  AND (?4 = '' OR window = ?4)
  AND (?5 = '' OR pane = ?5)
  AND (?6 = '' OR timestamp < ?6)
  AND (?7 = '' OR timestamp > ?7)
  AND (?8 = '' OR (?8 = 'read' AND read_timestamp != '') OR (?8 = 'unread' AND read_timestamp = ''))
ORDER BY id ASC
`

type ListNotificationsParams struct {
	StateFilter     interface{}
	LevelFilter     interface{}
	SessionFilter   interface{}
	WindowFilter    interface{}
	PaneFilter      interface{}
	OlderThanCutoff interface{}
	NewerThanCutoff interface{}
	ReadFilter      interface{}
}

type ListNotificationsRow struct {
	ID            int64
	Timestamp     string
	State         string
	Session       string
	Window        string
	Pane          string
	Message       string
	PaneCreated   string
	Level         string
	ReadTimestamp string
}

func (q *Queries) ListNotifications(ctx context.Context, arg ListNotificationsParams) ([]ListNotificationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listNotifications,
		arg.StateFilter,
		arg.LevelFilter,
		arg.SessionFilter,
		arg.WindowFilter,
		arg.PaneFilter,
		arg.OlderThanCutoff,
		arg.NewerThanCutoff,
		arg.ReadFilter,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNotificationsRow
	for rows.Next() {
		var i ListNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.State,
			&i.Session,
			&i.Window,
			&i.Pane,
			&i.Message,
			&i.PaneCreated,
			&i.Level,
			&i.ReadTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nextNotificationID = `-- name: NextNotificationID :one
SELECT COALESCE(MAX(id), 0) + 1 AS next_id
FROM notifications
`

func (q *Queries) NextNotificationID(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, nextNotificationID)
	var next_id int64
	err := row.Scan(&next_id)
	return next_id, err
}

const updateReadTimestampByID = `-- name: UpdateReadTimestampByID :execresult
UPDATE notifications
SET read_timestamp = ?1, updated_at = ?2
WHERE id = ?3
`

type UpdateReadTimestampByIDParams struct {
	ReadTimestamp string
	UpdatedAt     string
	ID            int64
}

func (q *Queries) UpdateReadTimestampByID(ctx context.Context, arg UpdateReadTimestampByIDParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateReadTimestampByID, arg.ReadTimestamp, arg.UpdatedAt, arg.ID)
}

const upsertNotification = `-- name: UpsertNotification :exec
INSERT INTO notifications (
    id,
    timestamp,
    state,
    session,
    window,
    pane,
    message,
    pane_created,
    level,
    read_timestamp,
    updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    timestamp = excluded.timestamp,
    state = excluded.state,
    session = excluded.session,
    window = excluded.window,
    pane = excluded.pane,
    message = excluded.message,
    pane_created = excluded.pane_created,
    level = excluded.level,
    read_timestamp = excluded.read_timestamp,
    updated_at = excluded.updated_at
`

type UpsertNotificationParams struct {
	ID            int64
	Timestamp     string
	State         string
	Session       string
	Window        string
	Pane          string
	Message       string
	PaneCreated   string
	Level         string
	ReadTimestamp string
	UpdatedAt     string
}

func (q *Queries) UpsertNotification(ctx context.Context, arg UpsertNotificationParams) error {
	_, err := q.db.ExecContext(ctx, upsertNotification,
		arg.ID,
		arg.Timestamp,
		arg.State,
		arg.Session,
		arg.Window,
		arg.Pane,
		arg.Message,
		arg.PaneCreated,
		arg.Level,
		arg.ReadTimestamp,
		arg.UpdatedAt,
	)
	return err
}
